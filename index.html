<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simetri Roset (v1.19 - Layout Disesuaikan)</title>
    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
    /* --- UI Refinement & Modern Look (v1.19 - Layout Adjustment) --- */
    :root {
        /* Palet Tema Terang (Default) - Slightly softer blues, refined grays */
        --primary-color: #007aff; --primary-hover: #006de0; --primary-active: #005ec4;
        --secondary-color: #6c757d; --secondary-hover: #5a6268; --secondary-active: #545b62;
        --success-color: #28a745; --success-hover: #218838; --success-active: #1e7e34;
        --danger-color: #dc3545; --danger-hover: #c82333; --danger-active: #bd2130;
        --info-color: #17a2b8; --info-hover: #138496; --info-active: #117a8b;
        --warning-color: #ffc107; --warning-hover: #e0a800; --warning-active: #d39e00;
        --light-color: #f8f9fa; --dark-color: #212529;

        --body-bg: #f9f9f9; /* Slightly off-white */
        --body-text: #343a40;
        --card-bg: #ffffff;
        --card-border: #e3e7ed; /* Softer border */
        --canvas-bg: #ffffff;
        --canvas-border: #d8dde3; /* Softer canvas border */
        --input-border: #ced4da;
        --input-focus-border: var(--primary-color);
        --input-focus-shadow: rgba(0, 123, 255, 0.25);
        --text-muted: #6c757d;
        --heading-color: #2a2f34; /* Slightly darker heading */
        --picker-border-color: #e8eaed;

        --hover-bg: #f1f3f5; /* Slightly lighter hover */
        --selected-bg: rgba(0, 123, 255, 0.1); /* Adjusted primary */
        --selected-border: rgba(0, 123, 255, 0.25);
        --disabled-opacity: 0.6;
        --shadow-sm: 0 2px 5px rgba(0, 0, 0, 0.05); /* Softer shadow */
        --shadow-md: 0 4px 10px rgba(0, 0, 0, 0.07);
        --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.09);

        /* Warna Garis Panduan */
        --grid-slice-color: #adb5bd;
        --grid-reflect-line-color: #fd7e14;

        /* Layout */
        --canvas-size: 600px; /* Ukuran max kanvas (UPDATED) */
        --controls-width: 330px; /* Slightly wider controls */
        --spacing: 1rem;
        --layout-gap: calc(var(--spacing) * 1.8); /* Adjusted gap */
        --border-radius: 0.5rem; /* Standard radius */
        --font-family-sans-serif: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; /* Modern stack */
        --transition-speed: 0.2s;
        --transition-speed-fast: 0.15s;
        --focus-ring-opacity: 0.25;
    }

    /* --- Override Tema Gelap --- */
    body.dark-mode {
        --primary-color: #4dabf7; --primary-hover: #74c0fc; --primary-active: #a5d8ff;
        --secondary-color: #909296; --secondary-hover: #adb5bd; --secondary-active: #ced4da; /* Adjusted grays */
        --success-color: #40c057; --success-hover: #69db7c; --success-active: #94f7ab;
        --danger-color: #fa5252; --danger-hover: #ff8787; --danger-active: #ffa8a8;
        --info-color: #3bc9db; --info-hover: #66d9e8; --info-active: #99e9f2;
        --warning-color: #fcc419; --warning-hover: #ffd868; --warning-active: #ffe09c;
        --light-color: #343a40; --dark-color: #f1f3f5;

        --body-bg: #18191a; /* Darker body */
        --body-text: #e4e6eb; /* Lighter text */
        --card-bg: #242526; /* Card background */
        --card-border: #3a3b3c; /* Subtle border */
        --canvas-bg: #ffffff; /* Kanvas tetap putih */
        --canvas-border: #44484d;
        --input-border: #4b4f54;
        --input-focus-border: var(--primary-color);
        --input-focus-shadow: rgba(77, 171, 247, 0.35);
        --text-muted: #a0a3a8;
        --heading-color: #f0f2f5; /* Brighter heading */
        --picker-border-color: #3a3b3c;

        --hover-bg: #3a3b3c; /* Hover background */
        --selected-bg: rgba(77, 171, 247, 0.15);
        --selected-border: rgba(77, 171, 247, 0.35);
        --shadow-sm: 0 2px 5px rgba(0, 0, 0, 0.25);
        --shadow-md: 0 4px 10px rgba(0, 0, 0, 0.3);
        --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.35);

        --grid-slice-color: #777;
        --grid-reflect-line-color: #fab005;
        --focus-ring-opacity: 0.35;
    }
    /* --- End Tema Gelap --- */

    *, *::before, *::after { box-sizing: border-box; }

    body {
        font-family: var(--font-family-sans-serif);
        display: flex; flex-direction: column; align-items: center;
        background-color: var(--body-bg); color: var(--body-text);
        margin: 0; padding: calc(var(--spacing) * 2); /* Standard padding */
        min-height: 100vh; font-size: 16px; line-height: 1.6; /* Standard line height */
        transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        -webkit-font-smoothing: antialiased; /* Smoother fonts */
        -moz-osx-font-smoothing: grayscale;
    }

    /* Kontainer Aplikasi Utama */
    .app-container {
        width: 100%;
        max-width: calc(var(--canvas-size) + var(--controls-width) + var(--layout-gap) + 2 * var(--spacing));
        display: flex; flex-direction: column; align-items: center;
        gap: calc(var(--spacing) * 1.8); /* Consistent gap */
    }

    header { width: 100%; text-align: center; margin-bottom: var(--spacing); }
    h1 { margin-top: 0; margin-bottom: 0.3rem; font-weight: 600; color: var(--heading-color); font-size: 2rem; transition: color var(--transition-speed) ease; letter-spacing: -0.5px; }
    h2 { margin-top: 0; margin-bottom: 0.7rem; font-size: 1.05rem; font-weight: 400; color: var(--text-muted); transition: color var(--transition-speed) ease; }
    .info-link button { background: none; border: none; color: var(--primary-color); text-decoration: none; font-weight: 500; cursor: pointer; padding: 0; font-size: 0.9em; font-family: inherit; border-bottom: 1px dashed var(--primary-color); transition: color var(--transition-speed-fast) ease, border-color var(--transition-speed-fast) ease; }
    .info-link button:hover { color: var(--primary-hover); border-bottom-style: solid; }

    /* Wrapper untuk layout 2 kolom */
    .main-layout {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: var(--layout-gap);
        justify-content: center;
        align-items: flex-start;
    }

    /* Kolom Kiri (Kanvas & Kontrol Utama & Alat Gambar) */
    .left-column {
        flex: 1 1 var(--canvas-size);
        max-width: var(--canvas-size); /* UPDATED */
        min-width: 300px;
        display: flex; flex-direction: column; align-items: stretch;
        gap: calc(var(--spacing) * 1.2); /* Consistent gap */
    }
    .canvas-instructions { font-size: 0.85rem; color: var(--text-muted); text-align: center; transition: color var(--transition-speed) ease; margin-bottom: calc(var(--spacing) * 0.2); }
    .canvas-container {
        position: relative;
        border: 1px solid var(--canvas-border);
        background-color: var(--canvas-bg);
        width: 100%; /* Lebar mengikuti left-column */
        height: auto;
        aspect-ratio: 1 / 1; /* Menjaga rasio 1:1 */
        max-width: var(--canvas-size); /* Batasi lebar maksimum */
        max-height: var(--canvas-size); /* Batasi tinggi maksimum */
        box-shadow: var(--shadow-md);
        overflow: hidden;
        border-radius: var(--border-radius);
        transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, background-color var(--transition-speed) ease;
        margin-left: auto; /* Pusatkan jika left-column lebih lebar */
        margin-right: auto;
    }
    #drawingCanvas, #gridCanvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; }
    #drawingCanvas { position: relative; z-index: 0; background-color: var(--canvas-bg); } /* Canvas bg controlled by var */
    .cursor-pencil { cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAJ5JREFUOE9jZKASYKSCaxjwv7f0Y2SgKnDqAjsFVQGr4M4L/P9/ZGBgYAZiP6DmkSA1DrBqAQYYGM7/X8y/gYGBgRFFgB0H6sH//0AnAwMDQwIk58/A////MwYGBlYoYP4zMDAwMhACY5EYQ5QBZP7//zMwMDAygALmBDAwMDByMIIAAgyQ0j8wMDAwMsA6sA9A7gAxnwwMAAEEALBwG0+0i3uFAAAAAElFTkSuQmCC') 0 16, crosshair; }
    .cursor-crosshair { cursor: crosshair; } .cursor-default { cursor: default; }
    #gridCanvas { pointer-events: none; z-index: 1; }

    /* --- Bar Alat Gambar (di bawah kanvas) --- */
    .drawing-tools-bar {
        display: grid;
        /* UPDATED: Grid 3 kolom karena warna dipindah */
        grid-template-columns: repeat(3, minmax(120px, 1fr));
        gap: calc(var(--spacing) * 1.2);
        width: 100%;
        margin-top: calc(var(--spacing) * 0.5);
        padding: calc(var(--spacing) * 1.2);
        border: 1px solid var(--card-border);
        background-color: var(--card-bg);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-sm);
        transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
    }
    /* Grup kontrol di dalam bar alat */
    .drawing-tools-bar .control-group {
        margin-bottom: 0; padding: 0; border: none;
        display: flex; flex-direction: column;
    }
    .drawing-tools-bar .control-group legend {
        font-size: 0.85rem; font-weight: 500;
        margin-bottom: calc(var(--spacing) * 0.6);
        padding-bottom: 0; border: none; text-align: left; width: 100%;
        color: var(--heading-color);
        transition: color var(--transition-speed) ease;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        opacity: 0.8;
    }
     /* Ukuran label di bar alat */
    .drawing-tools-bar .control-group label {
        padding: 0.5rem 0.8rem; font-size: 0.9rem; margin-bottom: 4px;
        display: flex; align-items: center; gap: 0.7em;
        border-radius: calc(var(--border-radius) * 0.8);
        border: 1px solid transparent;
        transition: background-color var(--transition-speed-fast) ease, border-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
        cursor: pointer;
    }
    .drawing-tools-bar .control-group label:hover:not(.selected) {
        background-color: var(--hover-bg); transform: scale(1.02);
    }
    .drawing-tools-bar .control-group label.selected {
        background-color: var(--selected-bg); border-color: var(--selected-border); font-weight: 500;
    }
    .drawing-tools-bar .control-group label.selected span:not(.custom-radio) { color: var(--primary-color); }
    body.dark-mode .drawing-tools-bar .control-group label.selected span:not(.custom-radio) { color: var(--primary-color); }

    /* Kontrol Footer (di bawah bar alat) */
    .canvas-footer-controls {
        display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
        gap: calc(var(--spacing) * 0.7);
        width: 100%; margin-top: calc(var(--spacing) * 0.8);
    }

    /* Kolom Kanan (Kontrol Simetri & Warna) */
    .right-column.controls-panel {
        flex: 0 0 var(--controls-width);
        background-color: var(--card-bg); padding: calc(var(--spacing) * 1.6);
        border: 1px solid var(--card-border); border-radius: var(--border-radius);
        box-shadow: var(--shadow-md); height: fit-content;
        transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        min-width: 290px;
    }

    /* NEW: Styling untuk Color Picker di Panel Kanan */
    .controls-panel .color-picker-group {
        margin-top: calc(var(--spacing) * 0.5); /* Sedikit spasi di atas */
    }
    .controls-panel #colorPickerContainer {
        width: 100%;
        min-height: 130px; /* Sesuaikan jika perlu */
        margin-top: 0.3rem;
        display: flex; justify-content: center; align-items: center;
        padding: 0.5rem 0; /* Tambahkan sedikit padding vertikal */
    }
    .controls-panel #colorPickerContainer .iro__colorPicker {
        max-width: 100%;
        border: 1px solid var(--picker-border-color);
        border-radius: calc(var(--border-radius) * 0.8);
        transition: border-color var(--transition-speed);
        box-shadow: var(--shadow-sm);
    }
    .controls-panel #colorPickerContainer .iro__colorPicker .iro__box,
    .controls-panel #colorPickerContainer .iro__colorPicker .iro__slider {
        box-shadow: inset 0 0 0 1px var(--picker-border-color);
        border-radius: calc(var(--border-radius) * 0.6);
    }
    body.dark-mode .controls-panel #colorPickerContainer .iro__colorPicker .iro__box,
    body.dark-mode .controls-panel #colorPickerContainer .iro__colorPicker .iro__slider {
        box-shadow: inset 0 0 0 1px var(--picker-border-color);
    }


    /* --- Tombol --- */
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5em; font-weight: 500; line-height: 1.5; text-align: center; text-decoration: none; vertical-align: middle; cursor: pointer; user-select: none; background-color: transparent; border: 1px solid var(--input-border); padding: 0.55rem 1rem; font-size: 0.9rem; border-radius: var(--border-radius); transition: color var(--transition-speed-fast) ease-in-out, background-color var(--transition-speed-fast) ease-in-out, border-color var(--transition-speed-fast) ease-in-out, box-shadow var(--transition-speed-fast) ease-in-out, transform var(--transition-speed-fast) ease-in-out; color: var(--body-text); }
    .btn svg { width: 1em; height: 1em; }
    .btn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px var(--input-focus-shadow); border-color: var(--input-focus-border); }
    .btn:disabled { pointer-events: none; opacity: var(--disabled-opacity); }
    .btn:not(:disabled):hover { border-color: var(--secondary-hover); background-color: var(--hover-bg); color: var(--body-text); transform: translateY(-2px); box-shadow: var(--shadow-sm); }
    .btn:not(:disabled):active { border-color: var(--secondary-active); background-color: var(--hover-bg); color: var(--body-text); transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
    .btn-outline-danger { color: var(--danger-color); border-color: var(--danger-color); } .btn-outline-danger:not(:disabled):hover { background-color: var(--danger-color); border-color: var(--danger-color); color: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); } .btn-outline-danger:not(:disabled):active { background-color: var(--danger-active); border-color: var(--danger-active); color: white; transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); } .btn-outline-danger:focus-visible { box-shadow: 0 0 0 3px rgba(var(--danger-color-rgb, 220 53 69) / var(--focus-ring-opacity)); border-color: var(--danger-hover); }
    .btn-outline-success { color: var(--success-color); border-color: var(--success-color); } .btn-outline-success:not(:disabled):hover { background-color: var(--success-color); border-color: var(--success-color); color: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); } .btn-outline-success:not(:disabled):active { background-color: var(--success-active); border-color: var(--success-active); color: white; transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); } .btn-outline-success:focus-visible { box-shadow: 0 0 0 3px rgba(var(--success-color-rgb, 40 167 69) / var(--focus-ring-opacity)); border-color: var(--success-hover); }
    .btn-outline-info { color: var(--info-color); border-color: var(--info-color); } .btn-outline-info:not(:disabled):hover { background-color: var(--info-color); border-color: var(--info-color); color: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); } .btn-outline-info:not(:disabled):active { background-color: var(--info-active); border-color: var(--info-active); color: white; transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); } .btn-outline-info:focus-visible { box-shadow: 0 0 0 3px rgba(var(--info-color-rgb, 23 162 184) / var(--focus-ring-opacity)); border-color: var(--info-hover); }
    .btn-outline-secondary { color: var(--secondary-color); border-color: var(--input-border); } .btn-outline-secondary:not(:disabled):hover { background-color: var(--secondary-color); border-color: var(--secondary-color); color: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); } .btn-outline-secondary:not(:disabled):active { background-color: var(--secondary-active); border-color: var(--secondary-active); color: white; transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); } .btn-outline-secondary:focus-visible { box-shadow: 0 0 0 3px rgba(var(--secondary-color-rgb, 108 117 125) / var(--focus-ring-opacity)); border-color: var(--secondary-hover); }
    body.dark-mode .btn-outline-info:not(:disabled):hover, body.dark-mode .btn-outline-info:not(:disabled):active { color: var(--dark-color); }
    body.dark-mode .btn-outline-secondary:not(:disabled):hover, body.dark-mode .btn-outline-secondary:not(:disabled):active { color: var(--dark-color); }
    :root { --danger-color-rgb: 220, 53, 69; --success-color-rgb: 40, 167, 69; --info-color-rgb: 23, 162, 184; --secondary-color-rgb: 108, 117, 125; }
    body.dark-mode { --danger-color-rgb: 250, 82, 82; --success-color-rgb: 64, 192, 87; --info-color-rgb: 59, 201, 219; --secondary-color-rgb: 144, 146, 150; }

    /* Tombol Mode Gelap */
    #darkModeToggle { min-width: 110px; }
    #darkModeToggle .icon-sun, body:not(.dark-mode) #darkModeToggle .icon-moon { display: none; }
    body.dark-mode #darkModeToggle .icon-sun { display: inline-block; }
    body:not(.dark-mode) #darkModeToggle .icon-moon { display: inline-block; }

    /* --- Checkbox Label (Tampilkan Panduan di Footer) --- */
    .canvas-footer-controls label.toggle-label {
        cursor: pointer; display: inline-flex; align-items: center; gap: 0.6em;
        font-size: 0.9rem; padding: 0.55rem 1rem; border-radius: var(--border-radius);
        transition: background-color var(--transition-speed-fast) ease, color var(--transition-speed-fast) ease, border-color var(--transition-speed-fast) ease, box-shadow var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
        vertical-align: middle; color: var(--text-muted); border: 1px solid var(--input-border);
        background-color: var(--card-bg); user-select: none;
    }
    .canvas-footer-controls label.toggle-label:hover {
        background-color: var(--hover-bg); color: var(--body-text);
        border-color: var(--secondary-hover); transform: translateY(-2px); box-shadow: var(--shadow-sm);
    }
    .canvas-footer-controls input[type="checkbox"] {
        cursor: pointer; width: 1.1em; height: 1.1em; margin-right: 0;
        accent-color: var(--primary-color); vertical-align: middle;
        position: relative; top: -1px; flex-shrink: 0;
    }
    .canvas-footer-controls label.toggle-label:focus-within {
        outline: 2px solid transparent; outline-offset: 2px;
        box-shadow: 0 0 0 3px var(--input-focus-shadow); border-color: var(--input-focus-border);
    }


    /* --- Grup Kontrol (Umum - Sidebar & Bar Alat) --- */
    .control-group { border: none; padding: 0; margin: 0 0 calc(var(--spacing) * 1.1) 0; display: flex; flex-direction: column; }
    .control-group:last-child { margin-bottom: 0; }
    /* Legend di panel kontrol kanan */
    .controls-panel .control-group legend {
        font-weight: 600; margin-bottom: calc(var(--spacing) * 0.8); font-size: 1.05rem;
        padding-bottom: 0.5rem; border-bottom: 1px solid var(--card-border); width: 100%;
        color: var(--heading-color); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        letter-spacing: 0.1px;
    }
    /* Legend untuk Color Picker di panel kanan */
    .controls-panel .color-picker-group legend {
        margin-bottom: calc(var(--spacing) * 0.4); /* Kurangi margin bawah */
        padding-bottom: 0.4rem;
    }

    .control-group label {
        display: flex; align-items: center; gap: 0.7em; margin-bottom: 5px; cursor: pointer; font-size: 0.95rem;
        padding: 0.6rem 0.9rem; border-radius: calc(var(--border-radius) * 0.9);
        transition: background-color var(--transition-speed-fast) ease-in-out, border-color var(--transition-speed-fast) ease-in-out, color var(--transition-speed-fast) ease-in-out, box-shadow var(--transition-speed-fast) ease-in-out, transform var(--transition-speed-fast) ease;
        border: 1px solid transparent; position: relative; user-select: none;
    }
    .control-group label:hover:not(.selected) { background-color: var(--hover-bg); transform: translateX(3px); }
    .control-group input[type="radio"], .control-group input[type="checkbox"] { position: absolute; opacity: 0; pointer-events: none; width: 1px; height: 1px; }

    /* Custom Controls (Radio/Checkbox) */
    .custom-radio, .custom-checkbox { display: inline-block; width: 1.2em; height: 1.2em; border: 1.5px solid var(--input-border); background-color: var(--card-bg); flex-shrink: 0; margin-right: 0; transition: background-color var(--transition-speed-fast) ease-in-out, border-color var(--transition-speed-fast) ease-in-out, box-shadow var(--transition-speed-fast) ease; position: relative; top: 0; }
    .custom-checkbox { border-radius: 0.25em; }
    input[type="checkbox"]:checked + .custom-checkbox { background-color: var(--primary-color); border-color: var(--primary-color); }
    input[type="checkbox"]:checked + .custom-checkbox::after { content: ''; display: block; width: 0.65em; height: 0.3em; border-left: 2px solid var(--card-bg); border-bottom: 2px solid var(--card-bg); transform: rotate(-45deg) translate(1px, -1px); position: absolute; left: 0.18em; top: 0.3em; }
    .custom-radio { border-radius: 50%; }
    input[type="radio"]:checked + .custom-radio { border-color: var(--primary-color); border-width: 2px; }
    input[type="radio"]:checked + .custom-radio::after { content: ''; display: block; width: 0.6em; height: 0.6em; background-color: var(--primary-color); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    input[type="radio"]:focus-visible + .custom-radio, input[type="checkbox"]:focus-visible + .custom-checkbox { box-shadow: 0 0 0 3px var(--input-focus-shadow); border-color: var(--input-focus-border); }
    .control-group label.selected { background-color: var(--selected-bg); border-color: var(--selected-border); }
    .control-group label.selected span:not(.custom-radio):not(.custom-checkbox) { color: var(--primary-color); font-weight: 500; }
    body.dark-mode .control-group label.selected span:not(.custom-radio):not(.custom-checkbox) { color: var(--primary-color); }


    /* Scrollbar Daftar Rotasi */
    .rotations-list { max-height: 260px; overflow-y: auto; padding-right: 10px; margin-right: -10px; scrollbar-width: thin; scrollbar-color: var(--secondary-color) transparent; }
    .rotations-list::-webkit-scrollbar { width: 8px; }
    .rotations-list::-webkit-scrollbar-track { background: transparent; border-radius: 4px; margin-top: 4px; margin-bottom: 4px; }
    .rotations-list::-webkit-scrollbar-thumb { background-color: var(--secondary-color); border-radius: 4px; border: 2px solid var(--card-bg); background-clip: content-box; }
    .rotations-list::-webkit-scrollbar-thumb:hover { background-color: var(--secondary-hover); }
    body.dark-mode .rotations-list::-webkit-scrollbar-thumb { border-color: var(--card-bg); }

    /* --- Modal --- */
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden; background-color: rgba(0, 0, 0, 0.6); padding: var(--spacing); backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px); animation: fadeInBg var(--transition-speed) ease-out forwards; }
    .modal.is-open { display: flex; align-items: center; justify-content: center; }
    .modal-content { background-color: var(--card-bg); margin: auto; padding: calc(var(--spacing) * 1.8); border: none; border-radius: calc(var(--border-radius) * 1.1); width: 90%; max-width: 750px; box-shadow: var(--shadow-lg); position: relative; animation: modalSlideIn var(--transition-speed) ease-out forwards; transition: background-color var(--transition-speed) ease; max-height: 90vh; overflow-y: auto; }
    .modal-close { color: var(--secondary-color); position: absolute; top: calc(var(--spacing) * 0.8); right: calc(var(--spacing) * 1.2); font-size: 2.2rem; font-weight: 300; cursor: pointer; line-height: 1; transition: color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease; background: none; border: none; padding: 0.2rem 0.5rem; border-radius: 50%; }
    .modal-close:hover, .modal-close:focus { color: var(--danger-color); text-decoration: none; outline: none; transform: scale(1.15) rotate(90deg); }
    .modal-close:focus-visible { box-shadow: 0 0 0 3px var(--input-focus-shadow); }
    .modal h2 { margin-top: 0.1rem; color: var(--primary-color); font-weight: 600; margin-bottom: calc(var(--spacing) * 1.2); transition: color var(--transition-speed) ease; font-size: 1.6rem; letter-spacing: -0.2px; }
    .modal p, .modal ul { font-size: 1rem; line-height: 1.7; color: var(--body-text); transition: color var(--transition-speed) ease; }
    .modal p { margin-bottom: calc(var(--spacing) * 1); }
    .modal ul { padding-left: 30px; margin-top: 0.8em; margin-bottom: calc(var(--spacing) * 1); }
    .modal li { margin-bottom: 0.8em; }
    .modal li::marker { color: var(--primary-color); font-size: 1.05em; }
    @keyframes fadeInBg { from { backdrop-filter: blur(0px); background-color: rgba(0, 0, 0, 0); } to { backdrop-filter: blur(3px); background-color: rgba(0, 0, 0, 0.6); } }
    @keyframes modalSlideIn { from { opacity: 0; transform: translateY(-25px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } }


    /* --- Responsiveness --- */
    @media (max-width: 1024px) { /* Sedikit lebih lebar dari 900px */
        .app-container {
             /* Sesuaikan max-width jika perlu, tapi biarkan flexbox menangani */
             max-width: calc(var(--canvas-size) + var(--controls-width) + var(--layout-gap) * 0.9 + 2 * var(--spacing));
        }
        .main-layout {
            gap: calc(var(--layout-gap) * 0.9);
        }
        .right-column.controls-panel {
            flex-basis: calc(var(--controls-width) * 0.95); /* Sedikit lebih kecil */
        }
        .drawing-tools-bar {
             /* Biarkan 3 kolom jika muat */
             grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }
        /* Pastikan color picker di panel kanan tidak terlalu lebar */
        .controls-panel #colorPickerContainer .iro__colorPicker {
             max-width: 260px; /* Batasi lebar picker */
        }
    }

    @media (max-width: 900px) { /* Layout berubah menjadi 1 kolom */
        body { padding: calc(var(--spacing) * 1.5); }
        .main-layout {
            flex-direction: column;
            align-items: center; /* Pusatkan item */
            gap: calc(var(--layout-gap) * 0.8);
        }
        .left-column {
            max-width: var(--canvas-size); /* Tetap batasi lebar kanvas */
            width: 100%; /* Ambil lebar penuh kontainer */
            order: -1; /* Pindahkan ke atas */
        }
        .right-column.controls-panel {
            width: 100%; /* Ambil lebar penuh kontainer */
            max-width: var(--canvas-size); /* Batasi lebar agar konsisten */
            flex-basis: auto; /* Hapus basis flex */
            order: 1; /* Pindahkan ke bawah */
        }
        .app-container {
            max-width: var(--canvas-size); /* Batasi lebar keseluruhan */
        }
        .drawing-tools-bar {
            gap: var(--spacing);
            /* Biarkan auto-fit untuk pembungkusan yang lebih baik */
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }
        .controls-panel #colorPickerContainer .iro__colorPicker {
             max-width: 100%; /* Biarkan mengisi ruang yang tersedia */
        }
    }

    @media (max-width: 768px) {
        h1 { font-size: 1.8rem; } h2 { font-size: 1rem; }
        .app-container { gap: calc(var(--spacing) * 1.5); }
        .left-column { gap: calc(var(--spacing) * 1); }
        .right-column.controls-panel { padding: calc(var(--spacing) * 1.3); }
        .controls-panel .control-group legend { font-size: 1rem; }
        .controls-panel .control-group label { font-size: 0.9rem; padding: 0.55rem 0.8rem; }
        .drawing-tools-bar {
            gap: calc(var(--spacing) * 0.9); padding: calc(var(--spacing) * 1);
            /* Coba 3 kolom jika muat, jika tidak 2 */
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        }
        .drawing-tools-bar .control-group legend { font-size: 0.8rem; margin-bottom: calc(var(--spacing) * 0.5); }
        .drawing-tools-bar .control-group label { font-size: 0.85rem; padding: 0.45rem 0.7rem; }
        .canvas-footer-controls { gap: calc(var(--spacing) * 0.6); }
        .canvas-footer-controls .btn, .canvas-footer-controls label.toggle-label { flex-grow: 1; justify-content: center; padding: 0.5rem 0.8rem; font-size: 0.85rem; }
        #darkModeToggle { flex-grow: 0; min-width: auto; }
        .modal-content { padding: calc(var(--spacing) * 1.5); margin-top: 10%; }
        .modal h2 { font-size: 1.4rem; }
        .rotations-list { max-height: 200px; }
    }

     @media (max-width: 480px) {
         body { padding: var(--spacing); line-height: 1.55; }
         h1 { font-size: 1.6rem; }
         .canvas-footer-controls { flex-direction: column; align-items: stretch; }
         .canvas-footer-controls .btn, .canvas-footer-controls label.toggle-label { width: 100%; justify-content: center; padding: 0.6rem 1rem; }
         .rotations-list { max-height: 160px; }
         .drawing-tools-bar {
             /* Paksa 2 kolom */
             grid-template-columns: 1fr 1fr;
             gap: calc(var(--spacing) * 0.8); padding: calc(var(--spacing) * 0.8);
         }
         .drawing-tools-bar .control-group label { padding: 0.4rem 0.6rem; }
         .btn { padding: 0.65rem 1rem; }
         .modal-content { width: 95%; margin-top: 8%; padding: calc(var(--spacing) * 1.2); }
         .modal h2 { font-size: 1.3rem; }
         .modal-close { font-size: 2rem; top: calc(var(--spacing) * 0.6); right: calc(var(--spacing) * 1); }
     }
</style>

</head>
<body class=""> <div class="app-container">
    <header>
        <h1>Simetri Roset</h1>
        <h2>(Grup Rotasi dan Dihedral)</h2>
        <div class="info-link">
             (<button id="infoBtn" type="button">Klik di sini</button> untuk info & instruksi.)
        </div>
    </header>

    <div class="main-layout">
        <div class="left-column">
            <div class="canvas-instructions">Gambar di area putih. Simetri diterapkan secara langsung.</div>
            <div class="canvas-container">
                <canvas id="drawingCanvas"></canvas>
                <canvas id="gridCanvas"></canvas>
            </div>

            <div class="drawing-tools-bar">
                 <fieldset class="control-group">
                     <legend>Alat</legend>
                     <label><input type="radio" name="tool" value="freehand" checked> <span class="custom-radio"></span><span>Goresan</span></label>
                     <label><input type="radio" name="tool" value="line"> <span class="custom-radio"></span><span>Garis</span></label>
                     <label><input type="radio" name="tool" value="rectangle"> <span class="custom-radio"></span><span>Persegi</span></label>
                     <label><input type="radio" name="tool" value="oval"> <span class="custom-radio"></span><span>Oval</span></label>
                     <label><input type="radio" name="tool" value="filledRect"> <span class="custom-radio"></span><span>Persegi Isi</span></label>
                     <label><input type="radio" name="tool" value="filledOval"> <span class="custom-radio"></span><span>Oval Isi</span></label>
                 </fieldset>
                 <fieldset class="control-group">
                     <legend>Lebar Garis</legend>
                     <label><input type="radio" name="lineWidth" value="1"> <span class="custom-radio"></span><span>1 px</span></label>
                     <label><input type="radio" name="lineWidth" value="2"> <span class="custom-radio"></span><span>2 px</span></label>
                     <label><input type="radio" name="lineWidth" value="3" checked> <span class="custom-radio"></span><span>3 px</span></label>
                     <label><input type="radio" name="lineWidth" value="5"> <span class="custom-radio"></span><span>5 px</span></label>
                     <label><input type="radio" name="lineWidth" value="8"> <span class="custom-radio"></span><span>8 px</span></label>
                     <label><input type="radio" name="lineWidth" value="13"> <span class="custom-radio"></span><span>13 px</span></label>
                     <label><input type="radio" name="lineWidth" value="21"> <span class="custom-radio"></span><span>21 px</span></label>
                 </fieldset>
                 <fieldset class="control-group">
                     <legend>Gaya Kursor</legend>
                     <label><input type="radio" name="cursorStyle" value="crosshair" checked> <span class="custom-radio"></span><span>Crosshair</span></label>
                     <label><input type="radio" name="cursorStyle" value="pencil"> <span class="custom-radio"></span><span>Pensil</span></label>
                     <label><input type="radio" name="cursorStyle" value="default"> <span class="custom-radio"></span><span>Default</span></label>
                 </fieldset>
                 </div>
            <footer class="canvas-footer-controls">
                 <button id="undoBtn" title="Urungkan (Ctrl+Z)" class="btn btn-outline-secondary" disabled type="button">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"> <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2z"/> <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466"/> </svg>
                     <span>Urungkan</span>
                 </button>
                 <button id="redoBtn" title="Ulangi (Ctrl+Y)" class="btn btn-outline-secondary" disabled type="button">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"> <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/> <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/> </svg>
                     <span>Ulangi</span>
                 </button>
                 <button id="clearBtn" title="Bersihkan Kanvas" class="btn btn-outline-danger" type="button">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"> <path d="M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5M11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84l.853-10.66h.538a.5.5 0 0 0 0-1zm-2.45 7.45c-.327.327-.86.327-1.187 0l-.02-.02-.02-.02c-.327-.327-.327-.86 0-1.187l.02-.02.02-.02c.327-.327.86-.327 1.187 0l.02.02.02.02c.327.327.327.86 0 1.187l-.02.02-.02.02zm2.235 0c-.327.327-.86.327-1.187 0l-.02-.02-.02-.02c-.327-.327-.327-.86 0-1.187l.02-.02.02-.02c.327-.327.86-.327 1.187 0l.02.02.02.02c.327.327.327.86 0 1.187l-.02.02-.02.02zm-4.61 0c-.327.327-.86.327-1.187 0l-.02-.02-.02-.02c-.327-.327-.327-.86 0-1.187l.02-.02.02-.02c.327-.327.86-.327 1.187 0l.02.02.02.02c.327.327.327.86 0 1.187l-.02.02-.02.02z"/> </svg>
                     <span>Bersihkan</span>
                 </button>
                 <label title="Tampilkan garis panduan rotasi/refleksi" class="toggle-label"> <input type="checkbox" id="showSlicesCheck">
                     <span>Tampilkan Panduan</span>
                 </label>
                 <button id="saveBtn" title="Simpan data gambar sebagai JSON" class="btn btn-outline-success" type="button">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"> <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v4.5h2a.5.5 0 0 1 .354.854l-2.5 2.5a.5.5 0 0 1-.708 0l-2.5-2.5A.5.5 0 0 1 5.5 6.5h2V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1z"/> </svg>
                     <span>Simpan</span>
                 </button>
                 <button id="loadBtn" title="Muat data gambar dari JSON" class="btn btn-outline-secondary" type="button">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"> <path d="M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.958 0 1.76.746 1.972 1.664l.122.516a.5.5 0 0 1-.972.23l-.122-.516A1.5 1.5 0 0 0 4.264 3H2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h10.97l-1.71 6.837A1.5 1.5 0 0 1 10.26 13H1.5v-1a.5.5 0 0 0-.5-.5V3.5zM.5 5a.5.5 0 0 0 0 1h15a.5.5 0 0 0 0-1zM11.76 4a.5.5 0 0 0-.488.607l1.71 6.837a.5.5 0 0 0 .488.393H15.5a.5.5 0 0 0 .5-.5V5a.5.5 0 0 0-.5-.5z"/> </svg>
                     <span>Muat...</span>
                 </button>
                 <input type="file" id="loadFile" accept=".json" style="display: none;">
                 <button id="downloadImageBtn" title="Unduh gambar sebagai PNG" class="btn btn-outline-info" type="button">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"> <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0"/> <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1z"/> </svg>
                     <span>Gambar</span>
                 </button>
                 <button id="darkModeToggle" title="Ganti Mode Terang/Gelap" class="btn btn-outline-secondary" type="button">
                     <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 0a.5.5 0 0 1-.707.707l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 3.05a.5.5 0 0 1-.707.707L2.343 2.343a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/></svg>
                     <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278zM4.858 1.311A7.269 7.269 0 0 0 1.025 7.71c0 4.021 3.278 7.277 7.318 7.277a7.316 7.316 0 0 0 5.205-2.162c-.337.042-.68.063-1.029.063-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286z"/></svg>
                     <span class="toggle-text">Mode Gelap</span> </button>
            </footer>
        </div>
        <aside class="right-column controls-panel">
             <fieldset class="control-group">
                  <legend>Tipe Simetri</legend>
                  <label> <input type="checkbox" id="reflectionToggle">
                      <span class="custom-checkbox"></span>
                      <span>Aktifkan Refleksi (D<sub>n</sub>)</span>
                  </label>
             </fieldset>
             <fieldset class="control-group">
                 <legend>Rotasi (n)</legend>
                 <div class="rotations-list"> <label><input type="radio" name="rotationOrder" value="1" checked> <span class="custom-radio"></span><span class="rotation-text">1 (C<sub>1</sub> / D<sub>1</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="2"> <span class="custom-radio"></span><span class="rotation-text">2 (C<sub>2</sub> / D<sub>2</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="3"> <span class="custom-radio"></span><span class="rotation-text">3 (C<sub>3</sub> / D<sub>3</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="4"> <span class="custom-radio"></span><span class="rotation-text">4 (C<sub>4</sub> / D<sub>4</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="5"> <span class="custom-radio"></span><span class="rotation-text">5 (C<sub>5</sub> / D<sub>5</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="6"> <span class="custom-radio"></span><span class="rotation-text">6 (C<sub>6</sub> / D<sub>6</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="7"> <span class="custom-radio"></span><span class="rotation-text">7 (C<sub>7</sub> / D<sub>7</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="8"> <span class="custom-radio"></span><span class="rotation-text">8 (C<sub>8</sub> / D<sub>8</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="9"> <span class="custom-radio"></span><span class="rotation-text">9 (C<sub>9</sub> / D<sub>9</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="10"> <span class="custom-radio"></span><span class="rotation-text">10 (C<sub>10</sub> / D<sub>10</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="12"> <span class="custom-radio"></span><span class="rotation-text">12 (C<sub>12</sub> / D<sub>12</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="16"> <span class="custom-radio"></span><span class="rotation-text">16 (C<sub>16</sub> / D<sub>16</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="20"> <span class="custom-radio"></span><span class="rotation-text">20 (C<sub>20</sub> / D<sub>20</sub>)</span></label>
                     <label><input type="radio" name="rotationOrder" value="24"> <span class="custom-radio"></span><span class="rotation-text">24 (C<sub>24</sub> / D<sub>24</sub>)</span></label>
                  </div>
             </fieldset>
             <fieldset class="control-group color-picker-group">
                   <legend>Warna</legend>
                   <div id="colorPickerContainer"></div>
              </fieldset>
        </aside>
    </div>
</div> <div id="infoModal" class="modal"> <div class="modal-content">
        <button class="modal-close" id="modalCloseBtn" title="Tutup (Esc)" type="button">×</button>
        <h2>Info & Instruksi Simetri Roset</h2>
        <p>Aplikasi ini mendemonstrasikan simetri roset, di mana pola diulang di sekitar titik pusat menggunakan rotasi dan refleksi opsional.</p>
        <ul>
            <li><strong>Tipe Simetri & Warna (Panel Kanan):</strong> Atur jumlah <strong>Rotasi (n)</strong>, centang <strong>Aktifkan Refleksi</strong> (untuk D<sub>n</sub>), dan pilih <strong>Warna</strong>.</li>
            <li><strong>Alat & Gaya (Di Bawah Kanvas):</strong> Pilih <strong>Alat</strong> gambar (Goresan, Garis, dll.), <strong>Lebar Garis</strong>, dan <strong>Gaya Kursor</strong>.</li>
            <li><strong>Menggambar:</strong> Klik dan seret (atau sentuh) pada kanvas putih untuk menggambar. Simetri diterapkan secara instan.</li>
            <li><strong>Tampilkan Panduan:</strong> Centang di bawah kanvas untuk menampilkan garis bantu rotasi (putus-putus C<sub>n</sub>) atau refleksi (solid oranye D<sub>n</sub>).</li>
            <li><strong>Kontrol Footer (di bawah bar alat):</strong> Gunakan Urungkan/Ulangi, Bersihkan, Simpan/Muat (data JSON), Unduh Gambar (PNG), dan ganti Mode Terang/Gelap.</li>
        </ul>
        <p><strong>Tips:</strong> Bereksperimenlah dengan urutan rotasi (n) yang berbeda dan aktifkan/nonaktifkan refleksi. Gambar bentuk sederhana agak jauh dari pusat untuk melihat efeknya paling jelas.</p>
    </div>
</div>

<script>
    // --- JAVASCRIPT (v1.19 - Layout Adjustment + Shape Rotation Fix) ---
document.addEventListener('DOMContentLoaded', () => {
    // --- Elemen DOM (Sama seperti sebelumnya) ---
    const canvas = document.getElementById('drawingCanvas');
    const gridCanvas = document.getElementById('gridCanvas');
    const canvasContainer = document.querySelector('.canvas-container');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const gridCtx = gridCanvas.getContext('2d');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const showSlicesCheck = document.getElementById('showSlicesCheck');
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');
    const loadFile = document.getElementById('loadFile');
    const downloadImageBtn = document.getElementById('downloadImageBtn');
    const reflectionToggle = document.getElementById('reflectionToggle');
    const controlGroups = document.querySelectorAll('.drawing-tools-bar .control-group, .controls-panel .control-group');
    const infoBtn = document.getElementById('infoBtn');
    const infoModal = document.getElementById('infoModal');
    const modalCloseBtn = document.getElementById('modalCloseBtn');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const rotationTextSpans = document.querySelectorAll('.controls-panel .rotations-list label .rotation-text');
    const colorPickerContainer = document.getElementById('colorPickerContainer');
    const drawingToolsBar = document.querySelector('.drawing-tools-bar');
    const controlsPanel = document.querySelector('.controls-panel');

    // --- Variabel State (Sama seperti sebelumnya) ---
    let isDrawing = false;
    let currentTool = 'freehand';
    let currentColor = '#007aff'; // Initialize with a default
    let currentLineWidth = 3;
    let currentRotationOrder = 1;
    let isReflectionEnabled = false;
    let currentCursorStyle = 'crosshair';
    let startX, startY, currentMouseX, currentMouseY;
    let history = [];
    let drawingActions = [];
    let historyIndex = -1;
    let currentPath = [];
    let lastKnownCanvasState = null;
    let rafId = null;
    let centerX, centerY;
    let colorPicker = null;
    const MAX_HISTORY_SIZE = 50;
    const pencilCursorDataUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAJ5JREFUOE9jZKASYKSCaxjwv7f0Y2SgKnDqAjsFVQGr4M4L/P9/ZGBgYAZiP6DmkSA1DrBqAQYYGM7/X8y/gYGBgRFFgB0H6sH//0AnAwMDQwIk58/A////MwYGBlYoYP4zMDAwMhACY5EYQ5QBZP7//zMwMDAygALmBDAwMDByMIIAAgyQ0j8wMDAwMsA6sA9A7gAxnwwMAAEEALBwG0+0i3uFAAAAAElFTkSuQmCC';
    const CANVAS_TARGET_SIZE = 600;

    // --- Setup (Termasuk resizeCanvas, applyContextSettings, applyCursorStyle, initializeColorPicker, Theme, Modal - Sama seperti sebelumnya) ---

    function resizeCanvas() {
        const containerWidth = canvasContainer.clientWidth;
        if (!containerWidth || containerWidth <= 0) return;
        const size = Math.min(containerWidth, CANVAS_TARGET_SIZE);
        const dpr = window.devicePixelRatio || 1;

        if (canvas.width === Math.floor(size * dpr) && canvas.height === Math.floor(size * dpr)) {
            centerX = size / 2;
            centerY = size / 2;
            drawSlices();
            return;
        }

        canvas.width = Math.floor(size * dpr);
        canvas.height = Math.floor(size * dpr);
        canvas.style.width = `${size}px`;
        canvas.style.height = `${size}px`;

        gridCanvas.width = Math.floor(size * dpr);
        gridCanvas.height = Math.floor(size * dpr);
        gridCanvas.style.width = `${size}px`;
        gridCanvas.style.height = `${size}px`;

        ctx.resetTransform();
        gridCtx.resetTransform();
        ctx.scale(dpr, dpr);
        gridCtx.scale(dpr, dpr);

        centerX = size / 2;
        centerY = size / 2;

        applyContextSettings();
        applyCursorStyle();
        drawSlices();
        redrawAllActions(true);
    }

    function applyContextSettings(targetCtx = ctx, settings = null) {
        const lw = settings ? settings.lineWidth : currentLineWidth;
        const col = settings ? settings.color : currentColor;
        targetCtx.lineCap = 'round';
        targetCtx.lineJoin = 'round';
        targetCtx.lineWidth = lw;
        targetCtx.strokeStyle = col;
        targetCtx.fillStyle = col;
    }

    function applyCursorStyle() {
        canvas.classList.remove('cursor-pencil', 'cursor-crosshair', 'cursor-default');
        canvas.style.cursor = '';
        if (currentCursorStyle === 'pencil') { canvas.style.cursor = `url('${pencilCursorDataUrl}') 0 16, crosshair`; canvas.classList.add('cursor-pencil'); }
        else if (currentCursorStyle === 'crosshair') canvas.classList.add('cursor-crosshair');
        else canvas.classList.add('cursor-default');
    }

    function initializeColorPicker() {
         if (!colorPickerContainer) { console.error("Wadah #colorPickerContainer tidak ditemukan!"); return; }
         try {
             currentColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); // Get initial color AFTER theme
             const initialBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--picker-border-color').trim();
             const containerWidth = colorPickerContainer.clientWidth;
             const pickerWidth = Math.min(280, (containerWidth > 40 ? containerWidth - 20 : 180));

             colorPicker = new iro.ColorPicker(colorPickerContainer, {
                 width: pickerWidth,
                 color: currentColor, // Use the retrieved color
                 borderWidth: 1,
                 borderColor: initialBorderColor,
                 layout: [ { component: iro.ui.Box, options: { boxLightness: false } }, { component: iro.ui.Slider, options: { sliderType: 'hue' } } ],
                 handleRadius: 7, padding: 5, sliderMargin: 12, sliderSize: 18,
             });
             colorPicker.on('color:change', function(color) { currentColor = color.hexString; applyContextSettings(); });
         } catch (error) { console.error("Gagal menginisialisasi color picker:", error); colorPickerContainer.innerHTML = '<p style="color: var(--danger-color); font-size: 0.9em; text-align: center; padding: 1em 0;">Pemilih warna gagal dimuat.</p>'; }
     }

    function applyTheme(theme) {
        const toggleText = darkModeToggle.querySelector('.toggle-text');
        if (theme === 'dark') { document.body.classList.add('dark-mode'); if (toggleText) toggleText.textContent = 'Mode Terang'; localStorage.setItem('theme', 'dark'); }
        else { document.body.classList.remove('dark-mode'); if (toggleText) toggleText.textContent = 'Mode Gelap'; localStorage.setItem('theme', 'light'); }
        if (colorPicker) {
             setTimeout(() => {
                 const newBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--picker-border-color').trim();
                 colorPicker.setOptions({ borderColor: newBorderColor });
                 // Update current color based on theme if it was the default primary
                 // Note: This might reset user's chosen color if they picked the default primary. Consider alternatives.
                 // currentColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
                 // colorPicker.color.hexString = currentColor; // Update picker UI too
                 // applyContextSettings(); // Apply the new color
             }, 50);
         }
         drawSlices();
    }
    function toggleTheme() { if (document.body.classList.contains('dark-mode')) { applyTheme('light'); } else { applyTheme('dark'); } }
    function initializeTheme() { const savedTheme = localStorage.getItem('theme'); const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches; if (savedTheme) { applyTheme(savedTheme); } else if (prefersDark) { applyTheme('dark'); } else { applyTheme('light'); } }
    function showInfoModal() { infoModal.style.display = 'flex'; infoModal.classList.add('is-open'); setTimeout(() => modalCloseBtn.focus(), 50); }
    function hideInfoModal() { infoModal.classList.remove('is-open'); setTimeout(() => { infoModal.style.display = 'none'; infoBtn.focus(); }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--transition-speed') || '0.2') * 1000); }
    infoBtn.addEventListener('click', showInfoModal);
    modalCloseBtn.addEventListener('click', hideInfoModal);
    infoModal.addEventListener('click', (event) => { if (event.target === infoModal) hideInfoModal(); });
    window.addEventListener('keydown', (event) => { if (event.key === 'Escape' && infoModal.style.display === 'flex') hideInfoModal(); });
    darkModeToggle.addEventListener('click', toggleTheme);

    // --- Event Listeners (handleControlChange, showSlicesCheck, clearBtn, undo/redo, save/load, download, keyboard shortcuts, mousedown/touchstart - Sama seperti sebelumnya) ---

    drawingToolsBar.addEventListener('change', handleControlChange);
    controlsPanel.addEventListener('change', handleControlChange);

    function handleControlChange(e) {
        const target = e.target;
        if ((target.type === 'radio' || target.type === 'checkbox') && target.closest('.control-group')) {
            const prevRot = currentRotationOrder;
            const prevRef = isReflectionEnabled;
            const prevCur = currentCursorStyle;

            updateSettings();
            updateSelectedLabels();

            if (currentCursorStyle !== prevCur) applyCursorStyle();

            if (currentRotationOrder !== prevRot || isReflectionEnabled !== prevRef) {
                updateRotationLabels();
                drawSlices();
                redrawAllActions();
            }

             if (target.name === 'tool' || target.name === 'lineWidth') {
                 applyContextSettings();
             }
        }
    }
    showSlicesCheck.addEventListener('change', drawSlices);
    clearBtn.addEventListener('click', () => { if (confirm("Apakah Anda yakin ingin membersihkan seluruh gambar? Tindakan ini tidak dapat diurungkan setelah disimpan.")) { clearCanvas(false); } });
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    saveBtn.addEventListener('click', saveJson);
    loadBtn.addEventListener('click', () => loadFile.click());
    loadFile.addEventListener('change', loadJson);
    downloadImageBtn.addEventListener('click', downloadCanvasImage);
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable || infoModal.style.display === 'flex') return;
        if (e.ctrlKey || e.metaKey) {
             if (e.key === 'z') { e.preventDefault(); undo(); } else if (e.key === 'y') { e.preventDefault(); redo(); }
             else if (e.key === 's') { e.preventDefault(); saveJson(); } else if (e.key === 'o') { e.preventDefault(); loadFile.click(); }
         }
    });
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('touchstart', (e) => { if(e.touches.length === 1) { e.preventDefault(); startDrawing(e.touches[0]); }}, { passive: false });

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeCanvas, 150);
    });

    // --- State Management (updateSettings, updateSelectedLabels, updateRotationLabels, saveState, restoreState, redrawBasedOnActions, undo, redo, updateUndoRedoButtons, clearCanvas, updateLastKnownCanvasState - Sama seperti sebelumnya) ---

    function updateSettings() {
        currentTool = document.querySelector('input[name="tool"]:checked')?.value ?? 'freehand';
        currentLineWidth = parseInt(document.querySelector('input[name="lineWidth"]:checked')?.value ?? '3', 10);
        currentRotationOrder = parseInt(document.querySelector('input[name="rotationOrder"]:checked')?.value ?? '1', 10);
        isReflectionEnabled = reflectionToggle.checked;
        currentCursorStyle = document.querySelector('input[name="cursorStyle"]:checked')?.value ?? 'crosshair';
        // Color is updated via color picker event listener
    }
    function updateSelectedLabels() {
        controlGroups.forEach(group => {
            group.querySelectorAll('label').forEach(label => {
                const input = label.querySelector('input[type="radio"], input[type="checkbox"]');
                if (input && (label.querySelector('.custom-radio') || label.querySelector('.custom-checkbox') || input.id === 'reflectionToggle')) {
                     label.classList.toggle('selected', input.checked);
                }
             });
         });
         const reflectionLabel = reflectionToggle.closest('label');
         if (reflectionLabel) {
             reflectionLabel.classList.toggle('selected', reflectionToggle.checked);
         }
    }
    function updateRotationLabels() {
         const prefix = isReflectionEnabled ? 'D' : 'C';
         rotationTextSpans.forEach(span => { const radio = span.closest('label')?.querySelector('input[name="rotationOrder"]'); if (radio) { const n = radio.value; span.innerHTML = `${n} (${prefix}<sub>${n}</sub>)`; } });
     }
    function saveState() {
        if (historyIndex < drawingActions.length - 1) {
            drawingActions.splice(historyIndex + 1);
            history.splice(historyIndex + 1);
        }
        try {
            const currentStateDataUrl = canvas.toDataURL();
            if (history.length > 0 && history[historyIndex] === currentStateDataUrl) {
                updateUndoRedoButtons();
                return;
            }
            history.push(currentStateDataUrl);
            historyIndex = history.length - 1;
            if (history.length > MAX_HISTORY_SIZE) {
                const itemsToRemove = history.length - MAX_HISTORY_SIZE;
                history.splice(0, itemsToRemove);
                drawingActions.splice(0, itemsToRemove);
                historyIndex -= itemsToRemove;
            }
        } catch (e) {
            console.error("Gagal menyimpan state kanvas:", e);
        } finally {
            updateUndoRedoButtons();
        }
    }
    function restoreState(targetHistoryIndex) {
         if (targetHistoryIndex < -1 || targetHistoryIndex >= history.length) return;
         historyIndex = targetHistoryIndex;
         const dpr = window.devicePixelRatio || 1;
         ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
         if (historyIndex === -1) {
             updateLastKnownCanvasState();
         } else {
             const img = new Image();
             img.onload = () => {
                 ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
                 updateLastKnownCanvasState();
             };
             img.onerror = (err) => {
                 console.error("Gagal memuat gambar riwayat:", err);
                 redrawBasedOnActions(historyIndex);
             };
             img.src = history[historyIndex];
         }
         updateUndoRedoButtons();
     }
    function redrawBasedOnActions(targetActionIndex) {
        const dpr = window.devicePixelRatio || 1;
        ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        const actionsToRedraw = drawingActions.slice(0, targetActionIndex + 1);
        const originalSettings = { lineWidth: currentLineWidth, color: currentColor };
        actionsToRedraw.forEach(action => {
            if (action && action.tool) {
                applyContextSettings(ctx, action);
                drawAction(action, ctx);
            }
        });
        applyContextSettings(ctx, originalSettings);
        updateLastKnownCanvasState();
    }
    function undo() { if (historyIndex >= 0) { restoreState(historyIndex - 1); } }
    function redo() { if (historyIndex < history.length - 1) { restoreState(historyIndex + 1); } }
    function updateUndoRedoButtons() {
         undoBtn.disabled = historyIndex < 0;
         redoBtn.disabled = historyIndex >= history.length - 1;
         clearBtn.disabled = history.length === 0 || (history.length === 1 && historyIndex === -1);
    }
    function clearCanvas(isInternal = false) {
         const dpr = window.devicePixelRatio || 1;
         ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
         gridCtx.clearRect(0, 0, gridCanvas.width / dpr, gridCanvas.height / dpr);
         if (!isInternal) {
             drawingActions = [];
             history = [];
             historyIndex = -1;
             lastKnownCanvasState = null;
             drawSlices();
             saveState();
         } else {
             updateLastKnownCanvasState();
         }
         updateUndoRedoButtons();
    }
    function updateLastKnownCanvasState() {
         if (isDrawing || !canvas.width || !canvas.height) return;
         try {
             const dataUrl = canvas.toDataURL();
             const img = new Image();
             img.onload = () => { lastKnownCanvasState = img; };
             img.onerror = () => { lastKnownCanvasState = null; console.warn("Failed to cache canvas state."); };
             img.src = dataUrl;
         } catch (e) {
             console.error("Error creating canvas state cache:", e);
             lastKnownCanvasState = null;
         }
    }

    // --- Drawing Logic ---
    function getMousePos(evt) {
         const rect = canvas.getBoundingClientRect();
         const dpr = window.devicePixelRatio || 1;
         const scaleX = canvas.width / dpr / rect.width;
         const scaleY = canvas.height / dpr / rect.height;
         const clientX = evt.clientX ?? evt.touches?.[0]?.clientX ?? 0;
         const clientY = evt.clientY ?? evt.touches?.[0]?.clientY ?? 0;
         return {
             x: (clientX - rect.left) * scaleX,
             y: (clientY - rect.top) * scaleY
         };
    }

    function startDrawing(e) {
        if (e.button && e.button !== 0) return;
        isDrawing = true;
        const pos = getMousePos(e);
        startX = pos.x;
        startY = pos.y;
        currentMouseX = startX;
        currentMouseY = startY;

        if (currentTool === 'freehand') {
            currentPath = [{ x: startX, y: startY }];
        }
        applyContextSettings();

        window.addEventListener('mousemove', handleDrawingMove);
        window.addEventListener('mouseup', stopDrawing);
        window.addEventListener('touchmove', handleDrawingMove, { passive: false });
        window.addEventListener('touchend', stopDrawing);
        window.addEventListener('touchcancel', stopDrawing);

        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(drawingLoop);
    }

    function handleDrawingMove(e) {
        if (!isDrawing) return;
        if (e.type === 'touchmove' && e.touches.length === 1) e.preventDefault();
        const pos = getMousePos(e);
        currentMouseX = pos.x;
        currentMouseY = pos.y;
        if (currentTool === 'freehand') {
            const lastPoint = currentPath[currentPath.length - 1];
            const dx = currentMouseX - lastPoint.x;
            const dy = currentMouseY - lastPoint.y;
            const minMoveDistSq = 4;
            if (dx * dx + dy * dy > minMoveDistSq) {
                currentPath.push({ x: currentMouseX, y: currentMouseY });
            }
        }
    }

    function drawingLoop() {
        if (!isDrawing) { rafId = null; return; }
        const dpr = window.devicePixelRatio || 1;
        ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

        if (lastKnownCanvasState) {
            try {
                ctx.drawImage(lastKnownCanvasState, 0, 0, canvas.width / dpr, canvas.height / dpr);
            } catch (error) {
                console.error("Error drawing cached state:", error);
                redrawAllActions(true);
            }
        } else {
            redrawAllActions(true);
        }

        applyContextSettings();
        const tempAction = {
            tool: currentTool, color: currentColor, lineWidth: currentLineWidth,
            startX: startX, startY: startY, endX: currentMouseX, endY: currentMouseY,
            path: (currentTool === 'freehand') ? currentPath : null
        };
        drawAction(tempAction, ctx); // Draw temporary action with symmetry

        rafId = requestAnimationFrame(drawingLoop);
    }

    function stopDrawing(e) {
        if (!isDrawing) return;
        isDrawing = false;
        window.removeEventListener('mousemove', handleDrawingMove);
        window.removeEventListener('mouseup', stopDrawing);
        window.removeEventListener('touchmove', handleDrawingMove);
        window.removeEventListener('touchend', stopDrawing);
        window.removeEventListener('touchcancel', stopDrawing);
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;

        const pos = getMousePos(e);
        const endX = (e.type === 'mouseup' || e.type === 'touchend') ? pos.x : currentMouseX;
        const endY = (e.type === 'mouseup' || e.type === 'touchend') ? pos.y : currentMouseY;

        if (currentTool === 'freehand' && currentPath.length > 0) {
            const last = currentPath[currentPath.length - 1];
            if (Math.hypot(last.x - endX, last.y - endY) > 0.1) {
                currentPath.push({ x: endX, y: endY });
            }
        }

        let addAction = false;
        const distSq = (startX - endX)**2 + (startY - endY)**2;
        const minPixelMoveSq = 4;

        if (currentTool === 'freehand') {
            addAction = currentPath.length > 0;
        } else {
            addAction = distSq >= minPixelMoveSq || currentTool === 'filledRect' || currentTool === 'filledOval';
        }

        if (addAction) {
            if (historyIndex < drawingActions.length - 1) {
                drawingActions.splice(historyIndex + 1);
                history.splice(historyIndex + 1);
            }
            const action = {
                tool: currentTool, color: currentColor, lineWidth: currentLineWidth,
                startX: startX, startY: startY, endX: endX, endY: endY,
                path: (currentTool === 'freehand' && currentPath) ? [...currentPath] : null
            };
            drawingActions.push(action);

            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            if(lastKnownCanvasState) ctx.drawImage(lastKnownCanvasState, 0, 0, canvas.width / dpr, canvas.height / dpr);
            applyContextSettings(ctx, action);
            drawAction(action, ctx); // Draw final action
            applyContextSettings(); // Restore current settings

            saveState();
        } else {
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            if (lastKnownCanvasState) {
                ctx.drawImage(lastKnownCanvasState, 0, 0, canvas.width / dpr, canvas.height / dpr);
            } else {
                redrawAllActions(true);
            }
            updateUndoRedoButtons();
        }
        currentPath = [];
        updateLastKnownCanvasState();
    }

    function redrawAllActions(skipCacheUpdate = false) {
         const dpr = window.devicePixelRatio || 1;
         ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
         const originalSettings = { lineWidth: currentLineWidth, color: currentColor };
         const actionsToDraw = drawingActions.slice(0, historyIndex + 1);
         actionsToDraw.forEach((action) => {
             if(action && action.tool) {
                 applyContextSettings(ctx, action);
                 drawAction(action, ctx);
             }
         });
         applyContextSettings(ctx, originalSettings);
         if (!skipCacheUpdate) {
             updateLastKnownCanvasState();
         }
         updateUndoRedoButtons();
    }

    // --- NEW / MODIFIED Drawing Functions ---

    function drawAction(action, targetCtx) {
        if (!action || !action.tool) return;

        if (action.tool === 'freehand') {
            // Freehand uses point transformation (unchanged)
            if (action.path && action.path.length > 0) {
                const transformedPaths = applySymmetryToPath(action.path);
                transformedPaths.forEach(p => drawFreehandPath(p, targetCtx));
            }
        } else {
            // --- Primitives use canvas transformations ---
            const N = currentRotationOrder;
            const reflect = isReflectionEnabled;
            const angleInc = (N > 0) ? (2 * Math.PI) / N : 0;

            // Store original settings for the action (color, width)
            // applyContextSettings(targetCtx, action); // Settings applied before calling drawAction

            // Loop through symmetry operations
            for (let i = 0; i < N; i++) {
                const angle = i * angleInc;

                // Instance 1: Rotation only
                targetCtx.save();
                targetCtx.translate(centerX, centerY); // Move origin to center
                targetCtx.rotate(angle);             // Rotate coordinate system
                targetCtx.translate(-centerX, -centerY); // Move origin back
                // Draw the original shape in the *now transformed* coordinate system
                drawPrimitiveRaw(action.startX, action.startY, action.endX, action.endY, action.tool, targetCtx);
                targetCtx.restore(); // Restore previous coordinate system

                // Instance 2: Reflection + Rotation (only if reflection enabled)
                if (reflect) {
                    targetCtx.save();
                    targetCtx.translate(centerX, centerY);
                    // Reflect across the center's vertical axis *then* rotate
                    // Or rotate then reflect across the rotated axis - let's reflect first
                    targetCtx.scale(-1, 1); // Reflect across local y-axis
                    targetCtx.rotate(angle); // Rotate the reflected system
                    targetCtx.translate(-centerX, -centerY);
                    // Draw the original shape again, it will appear reflected and rotated
                    drawPrimitiveRaw(action.startX, action.startY, action.endX, action.endY, action.tool, targetCtx);
                    targetCtx.restore();
                }
            }
        }
    }

    // NEW: Helper to draw primitive shapes without applying symmetry internally
    // Relies on the canvas context being pre-transformed.
    function drawPrimitiveRaw(x1, y1, x2, y2, tool, targetCtx) {
        targetCtx.beginPath();
        const w = x2 - x1;
        const h = y2 - y1;
        // Check if it was effectively a click (minimal movement)
        // Use a slightly larger threshold for robustness
        const isClickLike = Math.hypot(w, h) < 1.5;

        // Handle click-like drawing for filled shapes -> draw a dot
        if ((tool === 'filledRect' || tool === 'filledOval') && isClickLike) {
            drawDot(x1, y1, targetCtx); // Draw dot at the start point
            return; // Don't draw the tiny shape
        }

        // Draw the actual shape
        switch (tool) {
            case 'line':
                targetCtx.moveTo(x1, y1);
                targetCtx.lineTo(x2, y2);
                targetCtx.stroke();
                break;
            case 'rectangle':
            case 'filledRect':
                targetCtx.rect(x1, y1, w, h);
                if (tool === 'filledRect') targetCtx.fill();
                else targetCtx.stroke();
                break;
            case 'oval':
            case 'filledOval':
                // Use ellipse centered within the bounding box
                const rX = Math.abs(w / 2);
                const rY = Math.abs(h / 2);
                if (rX > 0.1 || rY > 0.1) { // Avoid drawing zero-size ellipses
                    const cX = x1 + w / 2; // Center X
                    const cY = y1 + h / 2; // Center Y
                    targetCtx.ellipse(cX, cY, rX, rY, 0, 0, 2 * Math.PI);
                    if (tool === 'filledOval') targetCtx.fill();
                    else targetCtx.stroke();
                }
                break;
        }
    }

    // --- Helper functions (kept for freehand and dot drawing) ---

    // Helper function to transform a single point (Used by applySymmetryToPath)
    const transformPt = (x, y, angle, doReflect) => {
        let cX = x - centerX;
        let cY = y - centerY;
        if (doReflect) cX = -cX; // Reflect across local y-axis
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const rX = cX * cosA - cY * sinA;
        const rY = cX * sinA + cY * cosA;
        return { x: rX + centerX, y: rY + centerY };
    };

    // Applies symmetry transformations to a path (array of points) -> Used for Freehand
    function applySymmetryToPath(path) {
        if (!path || path.length === 0) return [];
        const transformedPaths = [];
        const N = currentRotationOrder;
        const reflect = isReflectionEnabled;
        const angleInc = (N > 0) ? (2 * Math.PI) / N : 0;

        const applyTransformToPath = (originalPath, angle, doReflect) => {
            return originalPath.map(p => transformPt(p.x, p.y, angle, doReflect));
        };

        for (let i = 0; i < N; i++) {
            const angle = i * angleInc;
            transformedPaths.push(applyTransformToPath(path, angle, false));
            if (reflect) {
                transformedPaths.push(applyTransformToPath(path, angle, true));
            }
        }
        return transformedPaths;
    }

    // Draws a freehand path (array of points)
    function drawFreehandPath(path, targetCtx) {
        if (!path || path.length === 0) return;
        targetCtx.beginPath();
        targetCtx.moveTo(path[0].x, path[0].y);
        if (path.length === 1) {
            drawDot(path[0].x, path[0].y, targetCtx);
        } else {
            for (let i = 1; i < path.length; i++) {
                targetCtx.lineTo(path[i].x, path[i].y);
            }
            targetCtx.stroke();
        }
    }

    // Draws a small filled circle (dot) - Used for clicks on filled shapes & single-point freehand
    function drawDot(x, y, targetCtx) {
        const radius = Math.max(0.5, targetCtx.lineWidth / 2);
        const originalFill = targetCtx.fillStyle;
        targetCtx.fillStyle = targetCtx.strokeStyle; // Use stroke color for dot fill
        targetCtx.beginPath();
        targetCtx.ellipse(x, y, radius, radius, 0, 0, 2 * Math.PI);
        targetCtx.fill();
        targetCtx.fillStyle = originalFill; // Restore original fill style
    }

    // --- Grid/Slices Drawing (drawSlices - Sama seperti sebelumnya) ---
    function drawSlices() {
         const dpr = window.devicePixelRatio || 1;
         const logicalWidth = gridCanvas.width / dpr;
         const logicalHeight = gridCanvas.height / dpr;
         gridCtx.clearRect(0, 0, logicalWidth, logicalHeight);
         if (!showSlicesCheck.checked || !logicalWidth || !logicalHeight || !centerX || !centerY) return; // Added check for centerX/Y

         const N = currentRotationOrder;
         const reflect = isReflectionEnabled;
         const cx = centerX;
         const cy = centerY;
         if (N <= 0 || (N === 1 && !reflect)) return;

         gridCtx.save();
         gridCtx.lineWidth = 1 / dpr;
         const calculateEndPoint = (angle) => {
             const cosA = Math.cos(angle); const sinA = Math.sin(angle);
             let t = Infinity; const epsilon = 1e-9;
             if (Math.abs(cosA) > epsilon) {
                 const t_x0 = -cx / cosA; const t_xW = (logicalWidth - cx) / cosA;
                 if (t_x0 >= -epsilon) t = Math.min(t, t_x0);
                 if (t_xW >= -epsilon) t = Math.min(t, t_xW);
             }
             if (Math.abs(sinA) > epsilon) {
                 const t_y0 = -cy / sinA; const t_yH = (logicalHeight - cy) / sinA;
                 if (t_y0 >= -epsilon) t = Math.min(t, t_y0);
                 if (t_yH >= -epsilon) t = Math.min(t, t_yH);
             }
             t = (t === Infinity || t < epsilon) ? Math.max(logicalWidth, logicalHeight) * 1.5 : t;
             return { x: cx + t * cosA, y: cy + t * sinA };
         };

         const sliceColor = getComputedStyle(document.documentElement).getPropertyValue('--grid-slice-color').trim();
         const reflectColor = getComputedStyle(document.documentElement).getPropertyValue('--grid-reflect-line-color').trim();

         if (reflect) {
             gridCtx.strokeStyle = reflectColor;
             gridCtx.setLineDash([]); gridCtx.lineWidth = 1.2 / dpr;
             const angleIncrement = Math.PI / N;
             for (let i = 0; i < N; i++) {
                 const angle = i * angleIncrement; const endPoint = calculateEndPoint(angle);
                 gridCtx.beginPath(); gridCtx.moveTo(cx, cy); gridCtx.lineTo(endPoint.x, endPoint.y); gridCtx.stroke();
             }
         } else {
             if (N > 1) {
                 gridCtx.strokeStyle = sliceColor; const dash = 4 / dpr; gridCtx.setLineDash([dash, dash]); gridCtx.lineWidth = 1.0 / dpr;
                 const angleIncrement = (2 * Math.PI) / N;
                 for (let i = 0; i < N; i++) {
                     const angle = i * angleIncrement; const endPoint = calculateEndPoint(angle);
                     gridCtx.beginPath(); gridCtx.moveTo(cx, cy); gridCtx.lineTo(endPoint.x, endPoint.y); gridCtx.stroke();
                 }
             }
         }
         gridCtx.restore();
    }

    // --- Save/Load/Download (saveJson, loadJson, downloadCanvasImage - Sama seperti sebelumnya) ---
    function saveJson() {
         const data = {
             version: "1.19-layout-shapefix", // Updated version
             rotationOrder: currentRotationOrder, isReflectionEnabled: isReflectionEnabled,
             actions: drawingActions, currentTool: currentTool, currentColor: currentColor, currentLineWidth: currentLineWidth
         };
         const str = JSON.stringify(data, null, 2);
         const blob = new Blob([str], { type: 'application/json' });
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         const t = new Date().toISOString().replace(/[:.]/g, '-');
         const s = isReflectionEnabled ? 'D' : 'C';
         a.download = `roset_${s}${currentRotationOrder}_${t}.json`;
         a.href = url;
         document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }
    function loadJson(event) {
         const file = event.target.files[0];
         if (!file || !file.type.match('application/json')) { alert("Silakan pilih file JSON yang valid (.json)."); loadFile.value = null; return; }
         const reader = new FileReader();
         reader.onload = (e) => {
             try {
                 const data = JSON.parse(e.target.result);
                 if (!data || typeof data.rotationOrder !== 'number' || typeof data.isReflectionEnabled !== 'boolean' || !Array.isArray(data.actions)) { throw new Error("Format file JSON Roset tidak valid."); }
                 clearCanvas(true);
                 currentRotationOrder = data.rotationOrder; isReflectionEnabled = data.isReflectionEnabled;
                 drawingActions = data.actions || [];
                 const rotRadio = document.querySelector(`input[name="rotationOrder"][value="${currentRotationOrder}"]`); if (rotRadio) rotRadio.checked = true; else document.querySelector('input[name="rotationOrder"][value="1"]').checked = true;
                 reflectionToggle.checked = isReflectionEnabled;
                 currentColor = data.currentColor || getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); if (colorPicker) { colorPicker.color.hexString = currentColor; }
                 currentTool = data.currentTool || 'freehand';
                 currentLineWidth = data.currentLineWidth || 3;
                 const toolRadio = document.querySelector(`input[name="tool"][value="${currentTool}"]`); if(toolRadio) toolRadio.checked = true; else document.querySelector('input[name="tool"][value="freehand"]').checked = true;
                 const widthRadio = document.querySelector(`input[name="lineWidth"][value="${currentLineWidth}"]`); if(widthRadio) widthRadio.checked = true; else document.querySelector('input[name="lineWidth"][value="3"]').checked = true;
                 const cursorRadioChecked = document.querySelector(`input[name="cursorStyle"]:checked`); if (!cursorRadioChecked) { document.querySelector(`input[name="cursorStyle"][value="${currentCursorStyle}"]`).checked = true; }
                 updateSettings(); updateSelectedLabels(); updateRotationLabels(); applyCursorStyle(); applyContextSettings(); drawSlices();
                 history = []; historyIndex = -1; redrawAllActions(true); saveState();
                 alert(`Berhasil memuat data gambar dari "${file.name}".`);
             } catch (err) {
                 console.error("Load JSON error:", err); alert("Gagal memuat file: " + err.message); clearCanvas(false);
             } finally {
                 loadFile.value = null;
             }
         };
         reader.onerror = () => { alert("Gagal membaca file."); loadFile.value = null; };
         reader.readAsText(file);
    }
    function downloadCanvasImage() {
         const canvasToDownload = document.createElement('canvas');
         const ctxToDownload = canvasToDownload.getContext('2d');
         const dpr = window.devicePixelRatio || 1;
         const width = canvas.width; const height = canvas.height;
         canvasToDownload.width = width; canvasToDownload.height = height;
         ctxToDownload.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim() || '#ffffff';
         ctxToDownload.fillRect(0, 0, width, height);
         ctxToDownload.drawImage(canvas, 0, 0);
         if (showSlicesCheck.checked) { ctxToDownload.drawImage(gridCanvas, 0, 0); }
         const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
         const symType = isReflectionEnabled ? 'D' : 'C';
         const filename = `pola_roset_${symType}${currentRotationOrder}_${timestamp}.png`;
         const link = document.createElement('a'); link.download = filename;
         try {
             link.href = canvasToDownload.toDataURL('image/png');
             document.body.appendChild(link); link.click(); document.body.removeChild(link);
         } catch (e) {
             console.error("Download image error:", e); alert("Gagal membuat gambar unduhan: " + e.message);
         }
    }

    // --- Panggilan Setup Awal (Sama seperti sebelumnya) ---
    initializeTheme();
    updateSettings();
    initializeColorPicker(); // Init picker *after* theme and initial settings
    updateSelectedLabels();
    updateRotationLabels();
    resizeCanvas(); // Initial resize calculates centerX/Y needed for drawing
    applyCursorStyle();
    applyContextSettings();

    if(history.length === 0 && drawingActions.length === 0) {
        clearCanvas(true);
        saveState(); // Save initial empty state
    } else {
        redrawAllActions();
    }

    setTimeout(resizeCanvas, 100); // Ensure layout stable before final resize

    console.log("Simetri Roset (v1.19 - Perbaikan Rotasi Bentuk) Dimulai.");

}); // End DOMContentLoaded
</script>

</body>
</html>
